#+TITLE: clsh (Claude Shell) Technical Specification
#+DATE: [2025-08-20]

* Executive Summary

clsh is an intelligent shell wrapper that enhances traditional shells with natural language capabilities powered by Claude. It acts as a transparent layer between users and their chosen shell, providing AI-assisted error correction, natural language command substitution, and command generation while maintaining full compatibility with existing shell workflows.

* Core Features

** Natural Language Substitution
- *Syntax:* =~{natural language description}=
- *Usage:* Inline substitution within any command
- *Example:* =ls -la ~{files modified in the last hour}=
- *Behavior:*
  - Intercepts commands containing =~{...}= syntax
  - Sends context to Claude for interpretation
  - Presents suggested substitution with confirmation prompt
  - Substitutes approved text before sending to underlying shell
  - Shows spinner during AI processing

** Command Generation
- *Syntax:* =! natural language request=
- *Usage:* Generate shell commands from descriptions
- *Example:* =! show disk usage by directory=
- *Behavior:*
  - Sends request to Claude with system context
  - Presents generated command with confirmation prompt
  - Executes approved command in underlying shell

** Questions
- *Syntax:* =? question=
- *Usage:* Ask questions without executing commands
- *Example:* =? what does the df command do=
- *Behavior:*
  - Sends question to Claude
  - Returns explanation or answer
  - Does not suggest or execute commands

** Automatic Error Correction
- *Trigger:* Non-zero exit codes from commands
- *Behavior:*
  - Analyzes command, output, and error messages
  - Suggests corrections for:
    - Typos and misspellings
    - Missing arguments or flags
    - Incorrect syntax
    - Permission issues
    - Environmental problems
  - Presents correction with confirmation prompt

* Architecture

** Components

*** ClaudeShell (Main Controller)
- Manages readline interface and user interaction
- Coordinates between parser, AI client, and shell
- Handles command history and session state

*** CommandParser
- Identifies command types (substitution, generation, regular)
- Extracts natural language segments
- Validates syntax

*** ClaudeClient  
- Interfaces with Claude API via claude CLI
- Manages context and prompts
- Handles response parsing

*** ConfigLoader
- Multi-source configuration loading
- Priority order:
  1. Command-line specified file
  2. Environment variables
  3. =~/.config/clsh/= directory (*.yaml, *.json, *.js)
  4. =~/.clshrc= shell script
  5. Built-in defaults
- Dynamic configuration merging

** Data Flow

1. User input → ClaudeShell readline
2. ClaudeShell → CommandParser (identify type)
3. If AI needed → ClaudeClient → Claude API
4. If approved → Execute in shell via execa
5. If error → Automatic correction flow
6. Output → Terminal display

* Configuration

** File Locations
- Primary: =~/.config/clsh/settings.yaml=
- Alternative: =~/.config/clsh/config.yaml=
- Shell config: =~/.clshrc=
- Multiple configs supported (all *.yaml, *.json, *.js in config dir)

** Configuration Schema

#+BEGIN_SRC yaml
shell:
  default: /bin/bash       # Default shell path
  args: []                 # Additional shell arguments

syntax:
  substitution: "~{}"      # Natural language markers
  command: "!"             # Command generation prefix
  question: "?"            # Question prefix

error_handling:
  enabled: true
  ignore_exit_codes:       # Exit codes to ignore by command
    grep: [1]              # No matches found
    diff: [1]              # Files differ
    test: [1]              # Test failure

ai:
  model: sonnet            # Claude model to use
  max_context_lines: 100   # Max lines of context
  timeout_seconds: 10      # AI request timeout

permissions:
  substitution: always_ask # always_ask | never_ask | filter
  error_correction: always_ask
  command_generation: always_ask

history:
  enabled: true
  file: ~/.clsh_history
  max_entries: 10000
  save_corrections: true

appearance:
  theme: default           # default | minimal | verbose
  colors:
    ai_suggestion: cyan
    error: red
    success: green
    prompt: yellow
  indicators:
    processing: "⟳"        # or "..." for ASCII
    ai_prefix: "✨"        # or "[AI]" for ASCII
    error_prefix: "❌"     # or "[ERR]" for ASCII
#+END_SRC

* Implementation Details

** Command Interception
- All input processed through readline interface
- Commands parsed before shell execution
- Special syntax triggers AI processing
- Regular commands pass through unchanged

** Context Management
- Current working directory tracked
- Environment variables captured
- Recent command history maintained
- Error output preserved for correction

** Shell Integration
- Uses execa for shell execution
- Inherits environment from parent process
- Maintains shell state between commands
- Supports any POSIX-compliant shell

** Error Handling
- Non-zero exit codes trigger correction flow
- Configurable ignore patterns
- Context-aware error analysis
- Preserves original command in history

* API Reference

** ClaudeShell Class
#+BEGIN_SRC javascript
class ClaudeShell {
  constructor(config)
  async start()
  async run()
  handleCommand(input)
  executeCommand(command)
  handleErrorCorrection(command, error, output)
  showPrompt()
  cleanup()
}
#+END_SRC

** CommandParser Class
#+BEGIN_SRC javascript
class CommandParser {
  constructor(config)
  parse(input)
  hasSubstitution(command)
  extractSubstitutions(command)
}
#+END_SRC

** ClaudeClient Class
#+BEGIN_SRC javascript
class ClaudeClient {
  constructor(config)
  async suggestSubstitution(placeholder, command, context)
  async suggestCommand(request, context)
  async suggestCorrection(command, error, output, context)
}
#+END_SRC

** ConfigLoader Class
#+BEGIN_SRC javascript
class ConfigLoader {
  constructor()
  async load(configPath)
  async loadYamlFile(filePath)
  async loadJsonFile(filePath)
  async loadJsFile(filePath)
  async loadShellConfig(filePath)
  loadEnvConfig()
  mergeConfigs(configs)
}
#+END_SRC

* Appendix

** Command Examples
#+BEGIN_SRC bash
# Natural language substitution
$ ls ~{files larger than 10MB}
> Suggested: ls -lh | awk '$5 ~ /[0-9]+M/ && substr($5,1,length($5)-1) > 10'

# Command generation
$ ! find all Python files with TODO comments
> Suggested: grep -r "TODO" --include="*.py" .

# Ask a question
$ ? what does grep -r do
> The grep -r command recursively searches...

# Error correction
$ git push origin mian
> Error: fatal: 'mian' does not appear to be a git repository
> Suggested: git push origin main
#+END_SRC

** Configuration Examples
#+BEGIN_SRC yaml
# Minimal configuration
shell:
  default: /usr/bin/fish

# Advanced configuration  
syntax:
  substitution: "@{}"     # Custom markers
  command: "ai:"          # Custom prefix

error_handling:
  enabled: true
  ignore_exit_codes:
    custom-tool: [2, 3]   # Ignore specific exit codes
#+END_SRC
